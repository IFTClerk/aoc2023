MODULE UTILS
  USE, INTRINSIC :: ISO_FORTRAN_ENV
  IMPLICIT NONE

CONTAINS

ELEMENTAL LOGICAL FUNCTION ISA(c)
  CHARACTER, INTENT(in) :: c

  isa = ('a'.LE.c .AND. c.LE.'z') .OR. ('A'.LE.c .AND. c.LE.'Z')
END FUNCTION ISA

ELEMENTAL LOGICAL FUNCTION ISN(c)
  CHARACTER, INTENT(in) :: c

  isn = '0'.LE.c .AND. c.LE.'9'
END FUNCTION ISN

ELEMENTAL LOGICAL FUNCTION ISW(c)
  CHARACTER, INTENT(in) :: c

  isw = c.EQ.CHAR(9) .OR. c.EQ.' '
END FUNCTION ISW

INTEGER FUNCTION NLINES(f)
  CHARACTER*(*) f
  CHARACTER c
  INTEGER ios

  OPEN(UNIT=99, FILE=f, STATUS='old')

  nlines=0
  DO
     READ(99, '(A)', IOSTAT=ios) c
     IF (ios.EQ.IOSTAT_END) EXIT
     nlines = nlines + 1
  END DO

  CLOSE(99)
END FUNCTION NLINES

SUBROUTINE PRINTMTX(mtx)
  CHARACTER, DIMENSION(:,:) :: mtx
  INTEGER i, nrow, ncol

  nrow = SIZE(mtx, DIM=1)
  ncol = SIZE(mtx, DIM=2)
  DO i = 1,ncol
     PRINT *, mtx(i,:)
  END DO
END SUBROUTINE PRINTMTX

ELEMENTAL SUBROUTINE SWAP(x, y)
  INTEGER, INTENT(INOUT) :: x, y
  INTEGER t

  t = x
  x = y
  y = t
END SUBROUTINE SWAP

SUBROUTINE RESIZE(arr, n)
  INTEGER, DIMENSION(:), ALLOCATABLE :: arr, temp
  INTEGER n, s

  ALLOCATE(temp(n))
  ! temp = 0
  s = MIN(n, SIZE(arr))
  temp(1:s) = arr(1:s)
  CALL MOVE_ALLOC(temp, arr)
END SUBROUTINE RESIZE

SUBROUTINE PUSHONE(arr, val)
  INTEGER, DIMENSION(:), ALLOCATABLE :: arr
  INTEGER val, s

  s = SIZE(arr)+1
  CALL RESIZE(arr, s)
  arr(s) = val
END SUBROUTINE PUSHONE

SUBROUTINE PUSHARR(arr, varr)
  INTEGER, DIMENSION(:), ALLOCATABLE :: arr
  INTEGER, DIMENSION(:) :: varr
  INTEGER sa, sv

  sa = SIZE(arr)
  sv = SIZE(varr)
  CALL RESIZE(arr, sa + sv)
  arr(sa+1:sa+sv) = varr(1:sv)
END SUBROUTINE PUSHARR

END MODULE UTILS
