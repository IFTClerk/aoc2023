MODULE UTILS
  USE, INTRINSIC :: ISO_FORTRAN_ENV
  IMPLICIT NONE

  PRIVATE

  PUBLIC :: ISA
  PUBLIC :: ISN
  PUBLIC :: ISW
  PUBLIC :: NLINES
  PUBLIC :: PRINTMTX
  PUBLIC :: SWAP
  PUBLIC :: RESIZE
  PUBLIC :: PUSHONE
  PUBLIC :: PUSHARR

  INTERFACE PRINTMTX
     PROCEDURE PRINTMTX_I, PRINTMTX_C
  END INTERFACE PRINTMTX

  INTERFACE SWAP
     PROCEDURE SWAP_I, SWAP_C
  END INTERFACE SWAP

  INTERFACE RESIZE
     PROCEDURE RESIZE_I, RESIZE_C
  END INTERFACE RESIZE

  INTERFACE PUSHONE
     PROCEDURE PUSHONE_I, PUSHONE_C
  END INTERFACE PUSHONE

  INTERFACE PUSHARR
     PROCEDURE PUSHARR_I, PUSHARR_C
  END INTERFACE PUSHARR

CONTAINS

ELEMENTAL LOGICAL FUNCTION ISA(c)
  CHARACTER, INTENT(in) :: c

  isa = ('a'.LE.c .AND. c.LE.'z') .OR. ('A'.LE.c .AND. c.LE.'Z')
END FUNCTION ISA

ELEMENTAL LOGICAL FUNCTION ISN(c)
  CHARACTER, INTENT(in) :: c

  isn = '0'.LE.c .AND. c.LE.'9'
END FUNCTION ISN

ELEMENTAL LOGICAL FUNCTION ISW(c)
  CHARACTER, INTENT(in) :: c

  isw = c.EQ.CHAR(9) .OR. c.EQ.' '
END FUNCTION ISW

INTEGER FUNCTION NLINES(f)
  CHARACTER*(*) f
  CHARACTER c
  INTEGER ios

  OPEN(UNIT=99, FILE=f, STATUS='old')

  nlines=0
  DO
     READ(99, '(A)', IOSTAT=ios) c
     IF (ios.EQ.IOSTAT_END) EXIT
     nlines = nlines + 1
  END DO

  CLOSE(99)
END FUNCTION NLINES

SUBROUTINE PRINTMTX_I(mtx)
  INTEGER, DIMENSION(:,:) :: mtx
  INTEGER i, nrow, ncol

  nrow = SIZE(mtx, DIM=1)
  ncol = SIZE(mtx, DIM=2)
  DO i = 1,ncol
     WRITE(6, '(1X,*(I0,1X))') mtx(i,:)
  END DO
END SUBROUTINE PRINTMTX_I

SUBROUTINE PRINTMTX_C(mtx)
  CHARACTER, DIMENSION(:,:) :: mtx
  INTEGER i, nrow, ncol

  nrow = SIZE(mtx, DIM=1)
  ncol = SIZE(mtx, DIM=2)
  DO i = 1,ncol
     WRITE(6, '(1X,*(A1,1X))') mtx(i,:)
  END DO
END SUBROUTINE PRINTMTX_C

ELEMENTAL SUBROUTINE SWAP_I(x, y)
  INTEGER, INTENT(INOUT) :: x, y
  INTEGER t

  t = x
  x = y
  y = t
END SUBROUTINE SWAP_I

ELEMENTAL SUBROUTINE SWAP_C(x, y)
  CHARACTER, INTENT(INOUT) :: x, y
  CHARACTER t

  t = x
  x = y
  y = t
END SUBROUTINE SWAP_C

SUBROUTINE RESIZE_I(arr, n)
  INTEGER, DIMENSION(:), ALLOCATABLE :: arr, temp
  INTEGER n, s

  ALLOCATE(temp(n))
  ! temp = 0
  s = MIN(n, SIZE(arr))
  temp(1:s) = arr(1:s)
  CALL MOVE_ALLOC(temp, arr)
END SUBROUTINE RESIZE_I

SUBROUTINE RESIZE_C(arr, n)
  CHARACTER, DIMENSION(:), ALLOCATABLE :: arr, temp
  INTEGER n, s

  ALLOCATE(temp(n))
  ! temp = 0
  s = MIN(n, SIZE(arr))
  temp(1:s) = arr(1:s)
  CALL MOVE_ALLOC(temp, arr)
END SUBROUTINE RESIZE_C

SUBROUTINE PUSHONE_I(arr, val)
  INTEGER, DIMENSION(:), ALLOCATABLE :: arr
  INTEGER val
  INTEGER s

  s = SIZE(arr)+1
  CALL RESIZE(arr, s)
  arr(s) = val
END SUBROUTINE PUSHONE_I

SUBROUTINE PUSHONE_C(arr, val)
  CHARACTER, DIMENSION(:), ALLOCATABLE :: arr
  CHARACTER val
  INTEGER s

  s = SIZE(arr)+1
  CALL RESIZE(arr, s)
  arr(s) = val
END SUBROUTINE PUSHONE_C

SUBROUTINE PUSHARR_I(arr, varr)
  INTEGER, DIMENSION(:), ALLOCATABLE :: arr
  INTEGER, DIMENSION(:) :: varr
  INTEGER sa, sv

  sa = SIZE(arr)
  sv = SIZE(varr)
  CALL RESIZE(arr, sa + sv)
  arr(sa+1:sa+sv) = varr(1:sv)
END SUBROUTINE PUSHARR_I

SUBROUTINE PUSHARR_C(arr, varr)
  CHARACTER, DIMENSION(:), ALLOCATABLE :: arr
  CHARACTER, DIMENSION(:) :: varr
  INTEGER sa, sv

  sa = SIZE(arr)
  sv = SIZE(varr)
  CALL RESIZE(arr, sa + sv)
  arr(sa+1:sa+sv) = varr(1:sv)
END SUBROUTINE PUSHARR_C

END MODULE UTILS
